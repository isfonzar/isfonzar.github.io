<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Kubernetes Cluster from Scratch - Part 3 | Icaro’s Tech Blog</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Kubernetes Cluster from Scratch - Part 3" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my personal tech blog. Here I share my learnings, guides and insights about projects I’m working on." />
<meta property="og:description" content="This is my personal tech blog. Here I share my learnings, guides and insights about projects I’m working on." />
<link rel="canonical" href="http://localhost:4000/infrastructure/kubernetes-cluster-from-scratch-part-3/" />
<meta property="og:url" content="http://localhost:4000/infrastructure/kubernetes-cluster-from-scratch-part-3/" />
<meta property="og:site_name" content="Icaro’s Tech Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-27T07:25:31+01:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/infrastructure/kubernetes-cluster-from-scratch-part-3/","headline":"Kubernetes Cluster from Scratch - Part 3","dateModified":"2019-12-27T07:25:31+01:00","datePublished":"2019-12-27T07:25:31+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/infrastructure/kubernetes-cluster-from-scratch-part-3/"},"description":"This is my personal tech blog. Here I share my learnings, guides and insights about projects I’m working on.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Icaro's Tech Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Icaro&#39;s Tech Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About me</a><a class="page-link" href="/quotes">Quotes</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Kubernetes Cluster from Scratch - Part 3</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-12-27T07:25:31+01:00" itemprop="datePublished">Dec 27, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="what-is-the-kubernetes-control-plane">What is the Kubernetes Control Plane?</h2>

<p>The kubernetes control plane is a set of services that control the Kubernetes cluster.</p>

<p>Control Plane components “make global decisions about the cluster (e.g. scheduling) and detect and respond to cluster events (e.g. starting up a new pod when a replication controlle’s replicas field is unsatisfied)”</p>

<p>Control Plane components:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">kube-apiserver</code>: serves the kubernetes API, this allows users to interact with the cluster (kubectl communicates with the cluster using the API)</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">etcd</code>: Not part of Kubernetes, but it is essential to Kubernetes Control Plane, as Kubernetes uses it as a distributed datastore.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">kube-scheduler</code>: Schedules pods on available worker nodes.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">kube-controller-manager</code>: Runs a series of controllers that provide a wide range of functionality. It combines all of those into a single process.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">cloud-controller-manager</code>: Handles interaction with underlying cloud providers (Azure, AWS, Google Cloud, hybrid, etc…). (Not going to be used)</p>
  </li>
</ul>

<p>These control plane components need to be installed on each controller node.</p>

<h3 id="installing-kubernetes-control-plane">Installing Kubernetes Control Plane</h3>

<p>First, let’s install the control plane binaries on each control node:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/kubernetes/config

wget <span class="nt">-q</span> <span class="nt">--show-progress</span> <span class="nt">--https-only</span> <span class="nt">--timestamping</span> <span class="se">\</span>
  <span class="s2">"https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/linux/amd64/kube-apiserver"</span> <span class="se">\</span>
  <span class="s2">"https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/linux/amd64/kube-controller-manager"</span> <span class="se">\</span>
  <span class="s2">"https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/linux/amd64/kube-scheduler"</span> <span class="se">\</span>
  <span class="s2">"https://storage.googleapis.com/kubernetes-release/release/v1.10.2/bin/linux/amd64/kubectl"</span>

<span class="nb">chmod</span> +x kube-apiserver kube-controller-manager kube-scheduler kubectl

<span class="nb">sudo mv </span>kube-apiserver kube-controller-manager kube-scheduler kubectl /usr/local/bin/
</code></pre></div></div>

<h3 id="setting-up-the-kubernetes-api-server">Setting up the Kubernetes API Server</h3>

<p>This is going to be the directory for us to store some important files kubernetes is going to need.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /var/lib/kubernetes/

<span class="nb">sudo cp </span>ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem <span class="se">\</span>
  service-account-key.pem service-account.pem <span class="se">\</span>
  encryption-config.yaml /var/lib/kubernetes/
</code></pre></div></div>

<p>Then, let’s setup some environment variables that will be used to create the <code class="highlighter-rouge">systemd</code> unit file.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">INTERNAL_IP</span><span class="o">=</span><span class="si">$(</span>curl http://169.254.169.254/latest/meta-data/local-ipv4<span class="si">)</span> <span class="c"># this could have been set manually</span>
<span class="nv">CONTROLLER0_IP</span><span class="o">=</span>10.0.1.48
<span class="nv">CONTROLLER1_IP</span><span class="o">=</span>10.0.1.239
</code></pre></div></div>

<p>Then, generate the <code class="highlighter-rouge">kube-apiserver</code> unit file for <code class="highlighter-rouge">systemd</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | sudo tee /etc/systemd/system/kube-apiserver.service
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-apiserver </span><span class="se">\\</span><span class="sh">
  --advertise-address=</span><span class="k">${</span><span class="nv">INTERNAL_IP</span><span class="k">}</span><span class="sh"> </span><span class="se">\\</span><span class="sh">
  --allow-privileged=true </span><span class="se">\\</span><span class="sh">
  --apiserver-count=3 </span><span class="se">\\</span><span class="sh">
  --audit-log-maxage=30 </span><span class="se">\\</span><span class="sh">
  --audit-log-maxbackup=3 </span><span class="se">\\</span><span class="sh">
  --audit-log-maxsize=100 </span><span class="se">\\</span><span class="sh">
  --audit-log-path=/var/log/audit.log </span><span class="se">\\</span><span class="sh">
  --authorization-mode=Node,RBAC </span><span class="se">\\</span><span class="sh">
  --bind-address=0.0.0.0 </span><span class="se">\\</span><span class="sh">
  --client-ca-file=/var/lib/kubernetes/ca.pem </span><span class="se">\\</span><span class="sh">
  --enable-admission-plugins=Initializers,NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota </span><span class="se">\\</span><span class="sh">
  --enable-swagger-ui=true </span><span class="se">\\</span><span class="sh">
  --etcd-cafile=/var/lib/kubernetes/ca.pem </span><span class="se">\\</span><span class="sh">
  --etcd-certfile=/var/lib/kubernetes/kubernetes.pem </span><span class="se">\\</span><span class="sh">
  --etcd-keyfile=/var/lib/kubernetes/kubernetes-key.pem </span><span class="se">\\</span><span class="sh">
  --etcd-servers=https://</span><span class="nv">$CONTROLLER0_IP</span><span class="sh">:2379,https://</span><span class="nv">$CONTROLLER1_IP</span><span class="sh">:2379 </span><span class="se">\\</span><span class="sh">
  --event-ttl=1h </span><span class="se">\\</span><span class="sh">
  --experimental-encryption-provider-config=/var/lib/kubernetes/encryption-config.yaml </span><span class="se">\\</span><span class="sh">
  --kubelet-certificate-authority=/var/lib/kubernetes/ca.pem </span><span class="se">\\</span><span class="sh">
  --kubelet-client-certificate=/var/lib/kubernetes/kubernetes.pem </span><span class="se">\\</span><span class="sh">
  --kubelet-client-key=/var/lib/kubernetes/kubernetes-key.pem </span><span class="se">\\</span><span class="sh">
  --kubelet-https=true </span><span class="se">\\</span><span class="sh">
  --runtime-config=api/all </span><span class="se">\\</span><span class="sh">
  --service-account-key-file=/var/lib/kubernetes/service-account.pem </span><span class="se">\\</span><span class="sh">
  --service-cluster-ip-range=10.32.0.0/24 </span><span class="se">\\</span><span class="sh">
  --service-node-port-range=30000-32767 </span><span class="se">\\</span><span class="sh">
  --tls-cert-file=/var/lib/kubernetes/kubernetes.pem </span><span class="se">\\</span><span class="sh">
  --tls-private-key-file=/var/lib/kubernetes/kubernetes-key.pem </span><span class="se">\\</span><span class="sh">
  --v=2 </span><span class="se">\\</span><span class="sh">
  --kubelet-preferred-address-types=InternalIP,InternalDNS,Hostname,ExternalIP,ExternalDNS
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Last line was added to add the order of priority of the servers that determines how the kubeletes return their ip addresses, we give preference to the internal ip, otherwise they might report an IP address that might not work. Things may break without that flag:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--kubelet-preferred-address-types=InternalIP,InternalDNS,Hostname,ExternalIP,ExternalDNS
</code></pre></div></div>

<h3 id="setting-up-the-kubernetes-controller-manager">Setting up the Kubernetes Controller Manager</h3>

<p>First thing, let’s move this file to a location since it’s going to be needed by the kubernetes controller manager</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp </span>kube-controller-manager.kubeconfig /var/lib/kubernetes/
</code></pre></div></div>

<p>Then, let’s generate the kube-controller-manager systemd unit file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | sudo tee /etc/systemd/system/kube-controller-manager.service
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-controller-manager </span><span class="se">\\</span><span class="sh">
  --address=0.0.0.0 </span><span class="se">\\</span><span class="sh">
  --cluster-cidr=10.200.0.0/16 </span><span class="se">\\</span><span class="sh">
  --cluster-name=kubernetes </span><span class="se">\\</span><span class="sh">
  --cluster-signing-cert-file=/var/lib/kubernetes/ca.pem </span><span class="se">\\</span><span class="sh">
  --cluster-signing-key-file=/var/lib/kubernetes/ca-key.pem </span><span class="se">\\</span><span class="sh">
  --kubeconfig=/var/lib/kubernetes/kube-controller-manager.kubeconfig </span><span class="se">\\</span><span class="sh">
  --leader-elect=true </span><span class="se">\\</span><span class="sh">
  --root-ca-file=/var/lib/kubernetes/ca.pem </span><span class="se">\\</span><span class="sh">
  --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem </span><span class="se">\\</span><span class="sh">
  --service-cluster-ip-range=10.32.0.0/24 </span><span class="se">\\</span><span class="sh">
  --use-service-account-credentials=true </span><span class="se">\\</span><span class="sh">
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span></code></pre></div></div>

<h3 id="setting-up-the-kubernetes-scheduler">Setting up the Kubernetes Scheduler</h3>

<p>Move the file of the kube-scheduler into place:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo cp </span>kube-scheduler.kubeconfig /var/lib/kubernetes/
</code></pre></div></div>

<p>Now, we need to create a yaml configuration file for the scheduler:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | sudo tee /etc/kubernetes/config/kube-scheduler.yaml
apiVersion: componentconfig/v1alpha1
kind: KubeSchedulerConfiguration
clientConnection:
  kubeconfig: "/var/lib/kubernetes/kube-scheduler.kubeconfig"
leaderElection:
  leaderElect: true
</span><span class="no">EOF
</span></code></pre></div></div>

<p>And finally, the systemd unit file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | sudo tee /etc/systemd/system/kube-scheduler.service
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-scheduler </span><span class="se">\\</span><span class="sh">
  --config=/etc/kubernetes/config/kube-scheduler.yaml </span><span class="se">\\</span><span class="sh">
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Lastly, start and enable all of the service:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl daemon-reload <span class="c"># required every time we change systemd unit files</span>

<span class="nb">sudo </span>systemctl <span class="nb">enable </span>kube-apiserver kube-controller-manager kube-scheduler
<span class="nb">sudo </span>systemctl start kube-apiserver kube-controller-manager kube-scheduler
</code></pre></div></div>

<p>You can check the statues of the services:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl status kube-apiserver kube-controller-manager kube-scheduler
</code></pre></div></div>

<p>They should be all in <code class="highlighter-rouge">active (running)</code> status.
You can also check the status of the components through kubectl by running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get componentstatuses <span class="nt">--kubeconfig</span> admin.kubeconfig
</code></pre></div></div>

<p>At this point, the basics components of the kubernetes control place are up and running.</p>

<h3 id="enabling-http-health-checks">Enabling HTTP health checks</h3>

<h4 id="why-do-we-need-to-enable-http-health-checks">Why do we need to enable HTTP Health Checks?</h4>

<p>In the original <code class="highlighter-rouge">Kubernetes The Hard Way</code>, he uses a Google Cloud Platform load balancer, to avoid sending traffic against nodes that are unhealthy.</p>

<p>So we create a nginx proxy to propagate those status over HTTP (setting HTTPS health checks is too much trouble)</p>

<p>This step is not needed, but it’s a good practice.</p>

<p>Kubernetes only provides those via HTTPS, but sometimes you might need it through HTTP.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nginx
</code></pre></div></div>

<p>Create an nginx configuration file for the health check proxy:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> kubernetes.default.svc.cluster.local <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
server {
  listen      80;
  server_name kubernetes.default.svc.cluster.local;

  location /healthz {
     proxy_pass                    https://127.0.0.1:6443/healthz;
     proxy_ssl_trusted_certificate /var/lib/kubernetes/ca.pem;
  }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Set up the configuration:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mv </span>kubernetes.default.svc.cluster.local /etc/nginx/sites-available/kubernetes.default.svc.cluster.local
<span class="nb">sudo ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/kubernetes.default.svc.cluster.local /etc/nginx/sites-enabled/
<span class="nb">sudo </span>systemctl restart nginx
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>nginx
</code></pre></div></div>

<p>You can verify it’s working by:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-H</span> <span class="s2">"Host: kubernetes.default.svc.cluster.local"</span> <span class="nt">-i</span> http://127.0.0.1/healthz
</code></pre></div></div>

<h3 id="set-up-rbac-for-kubelet-authorization">Set up RBAC for Kubelet Authorization</h3>

<p>RBAC is Role-Based Access Control and is the mechanism to create roles and assign permissions to different users.</p>

<p>We need to make sure that the Kubernetes API has permission to access the Kubelet API on each node and perform certain common tasks, without this some functionalities might not work.</p>

<p>So let’s create a ClusterRose with the necessary permissions and assign that role to the Kubernetes user with a ClusterRoleBinding:</p>

<p>We only need to run this command on one of the servers, since now we are communicating to the Kubernetes cluster itself and the changes will be propagated.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | kubectl apply --kubeconfig admin.kubeconfig -f -
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kube-apiserver-to-kubelet
rules:
  - apiGroups:
      - ""
    resources:
      - nodes/proxy
      - nodes/stats
      - nodes/log
      - nodes/spec
      - nodes/metrics
    verbs:
      - "*"
</span><span class="no">EOF
</span></code></pre></div></div>

<p>And then, bind the role to the kubernetes user:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | kubectl apply --kubeconfig admin.kubeconfig -f -
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: system:kube-apiserver
  namespace: ""
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-apiserver-to-kubelet
subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: kubernetes
</span><span class="no">EOF
</span></code></pre></div></div>

<h3 id="setting-up-a-kube-api-frontend-load-balancer">Setting up a Kube API Frontend Load Balancer</h3>

<p>Log in into the API Load Balancer server and first, install nginx:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> nginx
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>nginx
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /etc/nginx/tcpconf.d
</code></pre></div></div>

<p>We need to include the following at the end of the nginx.conf:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vi /etc/nginx/nginx.conf
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include /etc/nginx/tcpconf.d/*;
</code></pre></div></div>

<p>That way, we cna add our configuration files in this folder and nginx will pick it up.</p>

<p>For the next step, we can set the following environment variables to help us:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CONTROLLER0_IP</span><span class="o">=</span>10.0.1.73
<span class="nv">CONTROLLER1_IP</span><span class="o">=</span>10.0.1.35
</code></pre></div></div>

<p>And now we create the load balancer nginx config file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> | sudo tee /etc/nginx/tcpconf.d/kubernetes.conf
stream {
    upstream kubernetes {
        server </span><span class="nv">$CONTROLLER0_IP</span><span class="sh">:6443;
        server </span><span class="nv">$CONTROLLER1_IP</span><span class="sh">:6443;
    }

    server {
        listen 6443;
        listen 443; # not really necessary
        proxy_pass kubernetes;
    }
}
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Then, we reload the nginx configuration:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nginx <span class="nt">-s</span> reload
</code></pre></div></div>

<p>And we can verify it’s working by running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-k</span> https://localhost:6443/version
</code></pre></div></div>

<p>(The <code class="highlighter-rouge">-k</code> is to make sure we don’t have problems with certificates since they were just generated)</p>

<h4 id="resources">Resources</h4>

<p><a href="https://kubernetes.io/docs/concepts/overview/components/#master-components">Kubernetes components</a></p>

  </div><div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://isfonzar.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            <a class="u-url" href="/infrastructure/kubernetes-cluster-from-scratch-part-3/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Icaro&#39;s Tech Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Icaro&#39;s Tech Blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/isfonzar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">isfonzar</span></a></li><li><a href="https://www.twitter.com/isfonzar"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">isfonzar</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This is my personal tech blog. Here I share my learnings, guides and insights about projects I&#39;m working on.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
